/-
  Hyperlocal/Transport/ToeplitzShiftGenerated.lean

  Minimal “Toeplitz / shift-generated” operator package:

    compPow S k          : k-fold iterate via composition
    shiftCombo n S c     : ∑_{k=0..n} c k • (compPow S k)
    ShiftGenerated n S A : ∃ c, A = shiftCombo n S c

  Main lemma:
    If A is shift-generated by shiftRₗ, then parity conjugation transports it
    to the same-coeff operator built from shiftLₗ:
      parityₗ ∘ₗ A = A_L ∘ₗ parityₗ.
-/

import Hyperlocal.Transport.ToeplitzLinear
import Mathlib.Data.Finset.Basic
import Mathlib.Tactic

noncomputable section

namespace Hyperlocal
namespace Transport

open scoped BigOperators

/-- Iterate an endomorphism by composition. -/
def compPow {n : ℕ} (S : EndW n) : ℕ → EndW n
  | 0     => (LinearMap.id : EndW n)
  | k + 1 => (compPow S k).comp S

@[simp] lemma compPow_zero {n : ℕ} (S : EndW n) :
    compPow S 0 = (LinearMap.id : EndW n) := rfl

@[simp] lemma compPow_succ {n : ℕ} (S : EndW n) (k : ℕ) :
    compPow S (k + 1) = (compPow S k).comp S := rfl

/-- Finite “shift polynomial” combination of iterates up to the window bound. -/
def shiftCombo (n : ℕ) (S : EndW n) (coeffs : ℕ → ℂ) : EndW n :=
  (Finset.range (n + 1)).sum (fun k => (coeffs k) • (compPow S k))

/-- “Shift-generated” predicate (Toeplitz surrogate). -/
def ShiftGenerated (n : ℕ) (SR A : EndW n) : Prop :=
  ∃ coeffs : ℕ → ℂ, A = shiftCombo n SR coeffs

/-- Parity transports powers of the right shift into powers of the left shift. -/
theorem parityₗ_comp_compPow_shiftRₗ (n k : ℕ) :
    (parityₗ n).comp (compPow (shiftRₗ n) k)
      =
    (compPow (shiftLₗ n) k).comp (parityₗ n) := by
  induction k with
  | zero =>
      simp [compPow]
  | succ k ih =>
      calc
        (parityₗ n).comp (compPow (shiftRₗ n) (k + 1))
            = (parityₗ n).comp ((compPow (shiftRₗ n) k).comp (shiftRₗ n)) := by
                simp [compPow]
        _ = ((parityₗ n).comp (compPow (shiftRₗ n) k)).comp (shiftRₗ n) := by
                simp [LinearMap.comp_assoc]
        _ = ((compPow (shiftLₗ n) k).comp (parityₗ n)).comp (shiftRₗ n) := by
                simp [ih]
        _ = (compPow (shiftLₗ n) k).comp ((parityₗ n).comp (shiftRₗ n)) := by
                simp [LinearMap.comp_assoc]
        _ = (compPow (shiftLₗ n) k).comp ((shiftLₗ n).comp (parityₗ n)) := by
                simp [parityₗ_comp_shiftRₗ_eq_shiftLₗ_comp_parityₗ]
        _ = ((compPow (shiftLₗ n) k).comp (shiftLₗ n)).comp (parityₗ n) := by
                simp [LinearMap.comp_assoc]
        _ = (compPow (shiftLₗ n) (k + 1)).comp (parityₗ n) := by
                simp [compPow]

/--
Main “operator” lemma:

If `A` is shift-generated by `shiftRₗ`, then conjugation by parity produces
the corresponding shift-generated operator built from `shiftLₗ`, and:
  parityₗ ∘ₗ A = A_L ∘ₗ parityₗ.
-/
theorem parityₗ_comp_shiftGenerated
    (n : ℕ) {A : EndW n}
    (hA : ShiftGenerated n (shiftRₗ n) A) :
    ∃ AL : EndW n,
      ShiftGenerated n (shiftLₗ n) AL ∧
      (parityₗ n).comp A = AL.comp (parityₗ n) := by
  classical
  rcases hA with ⟨coeffs, rfl⟩
  let AL : EndW n := shiftCombo n (shiftLₗ n) coeffs
  refine ⟨AL, ?_, ?_⟩
  · exact ⟨coeffs, rfl⟩
  · -- IMPORTANT: avoid `ext x` (it triggers `LinearMap.single` / `Pi.single` goals)
    apply LinearMap.ext
    intro x
    -- expand both sides at the Window level
    simp [AL, shiftCombo, LinearMap.comp_apply]
    -- rewrite each summand using the power-transport lemma, applied to x
    refine Finset.sum_congr rfl ?_
    intro k hk
    have hkWin :
        parity ((compPow (shiftRₗ n) k) x) =
          (compPow (shiftLₗ n) k) (parity x) := by
      have hLin := parityₗ_comp_compPow_shiftRₗ (n := n) k
      have hApp := congrArg (fun T : EndW n => T x) hLin
      simpa [LinearMap.comp_apply, parityₗ_apply] using hApp
    -- scale Window equality by coeffs k (stays in module scalar action, no `*` goals)
    simpa using congrArg (fun w : Window (n + 1) => (coeffs k) • w) hkWin

end Transport
end Hyperlocal
